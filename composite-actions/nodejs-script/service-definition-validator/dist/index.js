import*as e from"@actions/core";import*as t from"@actions/github";import{createRequire as r}from"node:module";import*as n from"js-yaml";var a={d:(e,t)=>{for(var r in t)a.o(t,r)&&!a.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const i=(o={getInput:()=>e.getInput,info:()=>e.info,setFailed:()=>e.setFailed,warning:()=>e.warning},s={},a.d(s,o),s);var o,s;const l=(e=>{var t={};return a.d(t,e),t})({context:()=>t.context,getOctokit:()=>t.getOctokit}),c=r(import.meta.url)("fs"),d=r(import.meta.url)("path"),u=(e=>{var t={};return a.d(t,e),t})({load:()=>n.load}),m={PROCESSOR:"processor",QUERY_API:"query-api",INPUT_API:"input-api"};async function p(e,t){try{const r=await c.promises.readFile(e,"utf8"),n=JSON.parse(r);if(!Array.isArray(n))throw new Error("Template JSON must be an array of objects.");return n.forEach(((e,r)=>{if(!e||"string"!=typeof e.keySuffix||void 0!==e.value&&"string"!=typeof e.value)throw new Error(`Invalid template at index ${r} in ${t} template.`)})),n}catch(r){throw r instanceof Error?(i.setFailed(`❌ Failed to load ${t} template from ${e}\nError: ${r.message}`),r):(i.setFailed(`❌ Failed to load ${t} template from ${e}\nUnknown error.`),new Error("Unknown error occurred while loading template."))}}(async()=>{await async function(){try{const e=i.getInput("service-definitions",{required:!0}),t=i.getInput("service-type",{required:!0});let r;try{if(r=JSON.parse(e),!Array.isArray(r))throw new Error("The 'service-definitions' input must be a JSON array of file paths.")}catch(e){return void(e instanceof Error?i.setFailed(`Invalid 'service-definitions' input. Ensure it's a valid JSON array.\nError: ${e.message}`):i.setFailed("Invalid 'service-definitions' input. Ensure it's a valid JSON array."))}const n=t.trim(),a=["PROCESSOR","QUERY_API","INPUT_API"];if(!a.includes(n))return void i.setFailed(`Invalid 'service-type' input. Allowed values are: ${a.join(", ")}.`);const o=m[n];if(!o)return void i.setFailed(`No folder mapping found for service-type '${n}'.`);const s=d.join(process.cwd(),"templates",o),f=d.join(s,"staging.json"),v=d.join(s,"production.json");try{await Promise.all([c.promises.access(f),c.promises.access(v)])}catch{return void i.setFailed(`❌ Template files not found in folder '${o}'. \n        Ensure that 'staging.json' and 'production.json' exist.`)}const[h,g]=await Promise.all([p(f,"staging"),p(v,"production")]),w={staging:h,production:g},y=[];await Promise.all(r.map((async e=>{let t;try{const r=await c.promises.readFile(e,"utf8"),n=u.load(r);if(!n||"object"!=typeof n)throw new Error("Parsed YAML content is empty or invalid.");t=n,i.info(`✅ YAML lint passed and parsed successfully for file: ${e}`)}catch(t){return void(t instanceof Error?i.setFailed(`❌ Failed to validate or parse YAML file: ${e}\nError: ${t.message}`):i.setFailed(`❌ Failed to validate or parse YAML file: ${e}\nUnknown error.`))}t.environments?Object.entries(w).forEach((([r,n])=>{const a=t.environments?.[r]?.env;if(a){const{missingVars:t,mismatchedVars:i}=function(e,t){const r=[],n=[],a={};return Object.entries(e).forEach((([e,r])=>{t.forEach((t=>{const n=t.keySuffix.toUpperCase();e.toUpperCase().endsWith(n)&&(a[n]||(a[n]=[]),a[n].push({variableName:e,value:r}))}))})),t.forEach((e=>{const t=e.keySuffix.toUpperCase(),i=a[t];i&&0!==i.length?i.forEach((({variableName:t,value:r})=>{e.value&&r!==e.value&&n.push({variableName:t,expectedValue:e.value,actualValue:r})})):r.push(e.keySuffix)})),{missingVars:r,mismatchedVars:n}}(a,n);y.push({filePath:e,environment:r,missingVars:t,mismatchedVars:i})}else i.warning(`⚠️ No 'env' section found for environment '${r}' in file: ${e}`)})):i.warning(`⚠️ No 'environments' section found in file: ${e}`)})));const E=function(e){let t="## 🛡️ Definition File(s) Environment Variables Validation Results\n\n";return 0===e.length?(t+="🔍 No validation results to display.",t):(e.forEach((e=>{var r;t+=`### 📄 File: \`${e.filePath}\` - Environment: **${r=e.environment,r?r.charAt(0).toUpperCase()+r.slice(1):r}**\n\n`,0!==e.missingVars.length||0!==e.mismatchedVars.length?(e.missingVars.length>0&&(t+=`#### ⚠️ Missing Environment Variables:\n${e.missingVars.map((e=>`- \`${e}\``)).join("\n")}\n\n`),e.mismatchedVars.length>0&&(t+="#### ❌ Mismatched Environment Variables:\n\n| Variable | Expected | Actual |\n|----------|----------|--------|\n",e.mismatchedVars.forEach((e=>{t+=`| \`${e.variableName}\` | \`${e.expectedValue}\` | \`${e.actualValue}\` |\n`})),t+="\n\n")):t+="✅ All environment variables are valid.\n\n"})),t)}(y);await async function(e){const t=process.env.GITHUB_TOKEN,r=l.getOctokit(t),{context:n}=l,a=n.payload.pull_request;if(!a)return void i.setFailed("🔴 This action must run on pull request events.");const{number:o,repo:s,owner:c}={number:a.number,repo:n.repo.repo,owner:n.repo.owner};try{const{data:t}=await r.rest.issues.listComments({owner:c,repo:s,issue_number:o,per_page:100}),n="## 🛡️ Definition File(s) Environment Variables Validation Results",a=t.find((e=>e.body?.startsWith(n)));a?(await r.rest.issues.updateComment({owner:c,repo:s,comment_id:a.id,body:e}),i.info("📝 Existing PR comment updated with new validation results.")):(await r.rest.issues.createComment({owner:c,repo:s,issue_number:o,body:e}),i.info("📝 New PR comment posted with validation results."))}catch(e){e instanceof Error?i.warning(`⚠️ Failed to post or update PR comment. Error: ${e.message}`):i.warning("⚠️ Failed to post or update PR comment. Unknown error.")}}(E),i.info("🎉 Validation results have been posted to the PR.")}catch(e){e instanceof Error?i.setFailed(`Unexpected error: ${e.message}`):i.setFailed("Unexpected error occurred.")}}()})().catch((e=>{i.setFailed(`Unhandled error: ${e}`)}));
//# sourceMappingURL=index.js.map